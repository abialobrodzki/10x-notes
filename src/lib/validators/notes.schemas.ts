import { z } from "zod";
import { uuidSchema, dateISOSchema, sortOrderSchema, paginationQuerySchema } from "./shared.schemas";

/**
 * Validation schema for GET /api/notes query parameters
 * Handles filtering, sorting, and pagination for notes list
 */
export const notesListQuerySchema = z
  .object({
    /**
     * Filter by specific tag ID
     * Optional - if not provided, returns notes from all user's tags
     */
    tag_id: uuidSchema.optional(),

    /**
     * Filter by goal achievement status
     * Optional - if not provided, returns notes with any status
     */
    goal_status: z.enum(["achieved", "not_achieved", "undefined"]).optional(),

    /**
     * Filter notes from this date onwards (inclusive)
     * Format: YYYY-MM-DD
     */
    date_from: dateISOSchema.optional(),

    /**
     * Filter notes up to this date (inclusive)
     * Format: YYYY-MM-DD
     */
    date_to: dateISOSchema.optional(),

    /**
     * Include notes from tags shared by other users
     * Default: false (only own notes)
     */
    include_shared: z.coerce.boolean().default(false),

    /**
     * Sort field
     * Default: 'meeting_date' (most recent meetings first)
     */
    sort_by: z.enum(["meeting_date", "created_at", "updated_at"]).default("meeting_date"),

    /**
     * Sort order
     * Default: 'desc' (newest first)
     */
    order: sortOrderSchema,
  })
  .merge(paginationQuerySchema)
  .refine(
    (data) => {
      // Validate that date_from is before date_to (if both provided)
      if (data.date_from && data.date_to) {
        return new Date(data.date_from) <= new Date(data.date_to);
      }
      return true;
    },
    {
      message: "date_from must be before or equal to date_to",
      path: ["date_from"],
    }
  );

/**
 * TypeScript type inferred from Zod schema
 * Use this type for validated query parameters
 */
export type NotesListQueryInput = z.infer<typeof notesListQuerySchema>;

/**
 * Validation schema for POST /api/notes
 * Creates a new note with tag assignment (XOR logic: tag_id OR tag_name)
 */
export const createNoteSchema = z
  .object({
    /**
     * Raw meeting notes content
     * Required - max 5000 characters
     */
    original_content: z.string().min(1, "Content is required").max(5000, "Content exceeds 5000 character limit"),

    /**
     * AI-generated or manual summary
     * Optional - max 2000 characters, can be null
     */
    summary_text: z.string().max(2000, "Summary exceeds 2000 character limit").nullable().optional(),

    /**
     * Goal achievement status
     * Optional - can be null
     */
    goal_status: z.enum(["achieved", "not_achieved", "undefined"]).nullable().optional(),

    /**
     * Suggested tag name (from AI or user input)
     * Optional - can be null
     */
    suggested_tag: z.string().nullable().optional(),

    /**
     * Meeting date
     * Optional - defaults to current date if not provided
     * Format: YYYY-MM-DD
     */
    meeting_date: dateISOSchema.optional(),

    /**
     * Whether summary was generated by AI
     * Optional - auto-set to false when summary_text is null
     */
    is_ai_generated: z.coerce.boolean().optional(),

    /**
     * Existing tag ID (UUID)
     * Optional - use XOR with tag_name (exactly one must be provided)
     */
    tag_id: uuidSchema.optional(),

    /**
     * Tag name to find or create
     * Optional - use XOR with tag_id (exactly one must be provided)
     */
    tag_name: z.string().min(1, "Tag name cannot be empty").optional(),
  })
  .strict()
  .superRefine((data, ctx) => {
    // XOR validation: exactly one of tag_id or tag_name must be provided
    const hasId = !!data.tag_id;
    const hasName = !!data.tag_name;

    if (hasId === hasName) {
      // Either both provided or neither provided
      const message =
        hasId && hasName ? "Provide either tag_id or tag_name, not both" : "Either tag_id or tag_name is required";

      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message,
        path: ["tag_id"],
      });
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message,
        path: ["tag_name"],
      });
    }
  });

/**
 * TypeScript type inferred from Zod schema
 * Use this type for validated note creation input
 */
export type CreateNoteInput = z.infer<typeof createNoteSchema>;

/**
 * Validation schema for PATCH /api/notes/{id}
 * Updates selected note fields (partial update)
 * All fields are optional, but at least one must be provided
 */
export const updateNoteSchema = z
  .object({
    /**
     * AI-generated or manual summary
     * Optional - max 2000 characters, can be set to null
     */
    summary_text: z.string().max(2000, "Summary exceeds 2000 character limit").nullable().optional(),

    /**
     * Goal achievement status
     * Optional - can be set to enum value
     */
    goal_status: z.enum(["achieved", "not_achieved", "undefined"]).optional(),

    /**
     * Meeting date
     * Optional - Format: YYYY-MM-DD
     */
    meeting_date: dateISOSchema.optional(),

    /**
     * Tag ID to reassign note
     * Optional - must be a valid UUID owned by user
     */
    tag_id: uuidSchema.optional(),
  })
  .strict()
  .refine((data) => Object.keys(data).length > 0, {
    message: "At least one field must be provided for update",
  });

/**
 * TypeScript type inferred from Zod schema
 * Use this type for validated note update input
 */
export type UpdateNoteInput = z.infer<typeof updateNoteSchema>;
